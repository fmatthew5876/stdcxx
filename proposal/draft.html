<html><head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>A constexpr bitwise operations library for C++</title>
</head>

<body>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
	<tr>
		<td width="172" align="left" valign="top">Document number:</td>
		<td width="435"><span style="background-color: #FFFF00">NXXX</span>=YY-ZZZZ</td>
	</tr>
	<tr>
		<td width="172" align="left" valign="top">Date:</td>
		<td width="435">
			<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2013-11-10<!--webbot bot="Timestamp" endspan i-checksum="12112" --></td>
	</tr>
	<tr>
		<td width="172" align="left" valign="top">Project:</td>
		<td width="435">Programming Language C++, Library Working Group</td>
	</tr>
	<tr>
		<td width="172" align="left" valign="top">Reply-to:</td>
		<td width="435">Matthew Fioravante &lt;<a href="mailto:fmatthew5876@gmail.com">fmatthew5876@gmail.com</a>&gt;</td>
	</tr>
</table>


<h1>A constexpr bitwise operations library for C++</h1>


<p><a href="#Introduction">Introduction</a><br>
<a href="#Impact">Impact on the Standard</a><br>
<a href="#Motivation">Motivation</a><br>
<a href="#Goals">Design Goals and Scope</a><br>
<a href="#Implementation">Implementation Notes</a><br>
<a href="#Tech">Technical Specification</a><br>
<a href="#Acknowledgements">Acknowledgements</a></p>
<a href="#References">References</a></p>


<h2><a name="Introduction">Introduction</a></h2>

<p>This proposal adds support for low level bitwise and logical operations to C++.</p>

<h2><a name="Impact">Impact on the Standard</a></h2>

<p>This proposal is a pure library extension. In it's current form, it does not modify any exsiting headers.
It does not require any changes in the core language, and does not depend on any other library extensions.
While the reference implementation [<a name="#BitOpsReference">BitOpsReference</a>] has been implemented in
standard C++14, optimal implementations will require additional support from the compiler via compiler intrinsics.
</p>

<h2><a name="Motivation">Motivation</a></h2>

<p>The C and C++ languages provide an abstraction over the machine.
Most platforms provide the common arithmetic and logical operations, which are
accessed using the builtin operators inherited from C. These operations are the primtives, the
low level building blocks which are used to implement higher level abstractions.
</p>

<p>While arithmetic and logical operations are often the most commonly used
features when designing an algorithm, sometimes significant performance
benefits can be gained by directly manipulating the binary quantities contained
within the registers which make up this numerical abstraction.
Hardware vendors have understood this need, and many of them have provided
additional cpu instructions which allow the programmer to perform these
bitwise manipulations. Other bitwise manipulation algorithms
can be implemented using clever but non-intuitive combinations of
arithmetic and logical operations. Most importantly, for many bitwise algorithms, the most
efficent implementation varies greatly between hardware platforms.
These differences create an unreasonably large maintenance burden on the programmer.
</p>
<p>
Many online and print references including [<a href="#Anderson01">Anderson01</a>],
[<a href="Deitz01">Dietz01</a>], [<a href="Neumann01">Neumann01</a>], [<a href="Warren01">Warren01</a>],
are devoted to discussing the implementations of these algorithms.
Consider the implementation of a count trailing zeroes algorithm
used in [<a href="#Kostjuchenko01">Kostjuchenko01</a>]. There are several different implementations
presented here, all of which must be profiled and tested on each platform. 
None of them take advantage of machines with builtin instructions
for the count trailing zeroes algorithm. One who wishes to exploit 
the <code>bsf</code> or <code>tzcnt</code> intructions on Intel must rely on non-standard
compiler instrinsics or inline assembly. One must also provide 
backup implementations for other platforms which do not have such instructions.
</p>

<p>
Bitwise algorithms are general purpose tools which can be used in a wide
variety of domains and are the key to unlocking high performance in many
important algorithms. A bitwise operations library has beed badly needed in 
the C and C++ standard libraries for many years.
</p>


<h2><a name="Goals">Design Goals and Scope</a></h2>
<p>
There are seemingly endless ways one can manipulate binary quantities. How does one go
about choosing which ones to include in a library and which ones to exclude? 
How does one choose proper names for each function? Which algorithms can
be trivially converted into single instructions by the optimizer and which
actually require the programmer to declare their use through a function call?
We will address these questions with the following design goals.
</p>

<h3>Design Goal 1: Provide the programmer with better access to the machine</h3>

<p>
In 1970, the Digital Equipment Corporation announced the PDP11. 
This 16 bit machine has 3 instructions of interest, <code>ROR</code> (rotate right), 
<code>ROL</code> (rotate left), and <code>SWAB</code> (swap bytes).
These operations along with their later 32 and 64 bit variants are provided 
by many more modern machines as will be shown. As of 2013,
the programmer still does not have direct access to these instructions in modern C and C++.
</p>

<p>
Therefore, the first and most important goal of this proposal is to provide the programmer with better
access to the machine. We will present new functions for the standard library which can be implemented
using only few instructions if supported by the machine, using backup implementations
if no such support is provided by the hardware.
</p>

<h3>Design Goal 2: Provide a set of commonly used bitwise manipulation routines</h3>

<p>
In designing this proposal, we wish not just to limit ourselves to operations which may have
native machine instruction implementations on at least on platform. We would like to provide
a library of primitives which are commonly found to be reimplemented time and time again in different code bases.
The standard library already provides a rich set of containers and algorithms. What is missing is a 
set of bitwise manipulation primitives.
</p>

<p>
Of particular emphasis are algorithms whose most efficient implementations depend on the implementations of
other bitwise operations. A motivating example is checking whether a number is a power of 2. 
This universally useful and popular function has many possible implementations. Consider the following:
</p>

<code>
	bool ispow2(unsigned x) { return popcount(x) == 1; }
</code>
<br>
<code>
	bool ispow2(unsigned x) { return x != 0 && (x & (x -1)) == 0; }
</code>

<p>
In the above example, popcount() is the population count or number of 1 bits in x. 
On a machine with a popcount instruction, the first implementation uses less instructions
and no branches. Without a popcount instruction, the second version is the better choice
as computing popcount requires much more than a few logical operations and comparisons 
[<a href="#Deitz01">Dietz01</a>].  The above can be verified using Clang 3.3 [<a href="#Clang">Clang</a>]
with the <code>__builtin_popcount()</code> compiler instrinsic on an Intel machine with the <code>popcntl</code> instruction available.
</p>


<h2><a name="Implementation">Implementation Notes</a></h2>
Those who wish to implement the functions provided by this proposal must consider the following guidelines:
<ul>
	<li><b>Prefer</b> compiler intrinsics to inline assembly.
	The former allows important optimizations while the later does not. 
	As a motivating example, consider the count trailing zeros algorithm. On older intel machines, this is implemented
	with a <code>bsf</code> instruction followed by a <code>cmov</code> instruction to handle the case
	where the input is 0. In many contexts the optimizer is able to prove that the input is never 0 and thus
	the cmov instruction can be omitted. This optimization is impossible with inline assembly.</li>
</ul>


<h2><a name="Tech">Technical Specification</a></h2>
<p>
We will now describe the contents of the new <code><bitops></code> header. This is a procedural library implemented
entirely using <code>constexpr</code> free functions. Each function is classified into different groups to aid analysis and discussion
and each group will be presented one at a time. 
Several machine architectures were surveyed for their instruction references.
If the function can be implemented using native instructions it will be noted. 
Citations for each instruction reference have been omitted in order to reduce clutter.
A list of processor manual references can be found in the <a href="#References">References</a> section.
</p>

<p>Template arguments for each proposed function are named "integral" to indicate support
for all builtin integral types. The includes signed and unsigned integers.</p>

<h3>&ltbitops&gt Header Synopsis</h3>

<blockquote><pre>

//SHift Logical Left
template &lt;class integral&gt;
constexpr integral shll(integral x, int s) noexcept;

//SHift Logical Right
template &lt;class integral&gt;
constexpr integral shlr(integral x, int s) noexcept;

//SHift Arithmetic Left
template &lt;class integral&gt;
constexpr integral shal(integral x, int s) noexcept;

//SHift Arithmetic Right
template &lt;class integral&gt;
constexpr integral shar(integral x, int s) noexcept;

//ROTate Left
template &lt;class integral&gt;
constexpr integral rotl(integral x, int s) noexcept;

//ROTate Right
template &lt;class integral&gt;
constexpr integral rotr(integral x, int s) noexcept;

//CouNT Trailing 0's
template &lt;class integral&gt;
constexpr int cntt0(integral x) noexcept;

//CouNT Leading 0's
template &lt;class integral&gt;
constexpr int cntl0(integral x) noexcept;

//CouNT Trailing 1's
template &lt;class integral&gt;
constexpr int cntt1(integral x) noexcept;

//CouNT Leading 1's
template &lt;class integral&gt;
constexpr int cntl1(integral x) noexcept;

//POPulation COUNT
template &lt;class integral&gt;
constexpr int popcount(integral x) noexcept;

//PARITY
template &lt;class integral&gt;
constexpr int parity(integral x) noexcept;

//ReSeT Least Significant 1 Bit
template &lt;class integral&gt;
constexpr integral rstls1b(integral x) noexcept;

//SET Least Significant 0 Bit
template &lt;class integral&gt;
constexpr integral setls0b(integral x) noexcept;

//ISOlate Least Significant 1 Bit
template &lt;class integral&gt;
constexpr integral isols1b(integral x) noexcept;

//ISOlate Least Significant 0 Bit
template &lt;class integral&gt;
constexpr integral isols0b(integral x) noexcept;

//ReSeT Trailing 1's
template &lt;class integral&gt;
constexpr integral rstt1(integral x) noexcept;

//SET Trailing 0's
template &lt;class integral&gt;
constexpr integral sett0(integral x) noexcept;

//MaSK Trailing 0's
template &lt;class integral&gt;
constexpr integral maskt0(integral x) noexcept;

//MaSK Trailing 1's
template &lt;class integral&gt;
constexpr integral maskt1(integral x) noexcept;

//MaSK Trailing 0's and Least Significant 1 Bit
template &lt;class integral&gt;
constexpr integral maskt0ls1b(integral x) noexcept;

//MaSK Trailing 1's and Least Significant 0 Bit
template &lt;class integral&gt;
constexpr integral maskt1ls0b(integral x) noexcept;

//SET BIT
template &lt;class integral&gt;
constexpr integral setbit(integral x, int b) noexcept;

//ReSeT BIT
template &lt;class integral&gt;
constexpr integral rstbit(integral x, int b) noexcept;

//FLIP BIT
template &lt;class integral&gt;
constexpr integral flipbit(integral x, int b) noexcept;

//TEST BIT
template &lt;class integral&gt;
constexpr bool testbit(integral x, int b) noexcept;

//ReSeT BITS Greater Than
template &lt;class integral&gt;
constexpr integral rstbitsge(integral x, int b) noexcept;

//ReSeT BITS Less Than
template &lt;class integral&gt;
constexpr integral rstbitsle(integral x, int b) noexcept;

//SET BITS Greater Than
template &lt;class integral&gt;
constexpr integral setbitsge(integral x, int b) noexcept;

//SET BITS Less Than
template &lt;class integral&gt;
constexpr integral setbitsle(integral x, int b) noexcept;

//FLIP BITS Greater Than
template &lt;class integral&gt;
constexpr integral flipbitsge(integral x, int b) noexcept;

//FLIP BITS Less Than
template &lt;class integral&gt;
constexpr integral flipbitsle(integral x, int b) noexcept;

template &lt;class integral&gt;
constexpr integral reverse_bits(integral x, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral reverse_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral outer_perfect_shuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral outer_perfect_shuffle_bytes(integral x, int subword_bits=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral outer_perfect_unshuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral outer_perfect_unshuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral inner_perfect_shuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral inner_perfect_shuffle_bytes(integral x, int subword_bits=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral inner_perfect_unshuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral inner_perfect_unshuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral deposit_bits_right(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral deposit_bytes_right(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral deposit_bits_left(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral deposit_bytes_left(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;

template &lt;class integral&gt;
constexpr integral extract_bits_right(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral extract_bytes_right(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral extract_bits_left(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;
template &lt;class integral&gt;
constexpr integral extract_bytes_left(integral x, integral mask, int subword_bits=1, int num_words=1) noexcept;

</pre></blockquote>

<h3>&lt;cmath&gt; Header Synopsis</h3>

<blockquote><pre>
//IS POWer of 2
template &lt;class integral&gt;
constexpr bool ispow2(integral x) noexcept;

//CEILing Power of 2
template &lt;class integral&gt;
constexpr integral ceilp2(integral x) noexcept;

//FLOOR Power of 2
template &lt;class integral&gt;
constexpr integral floorp2(integral x) noexcept;


//SATurated ADDition
template &lt;class integral_l, class integral_r&gt;
constexpr auto satadd(integral_l l, integral_r r) noexcept -&gt; decltype(l + r);

//SATurated SUBtraction
template &lt;class integral_l, class integral_r&gt;
constexpr auto satsub(integral_l l, integral_r r) noexcept -&gt; decltype(l - r);

</pre></blockquote>

<h3>&lt;memory&gt; Header Synopsis</h3>

<blockquote><pre>
template &lt;class integral&gt;
constexpr bool is_aligned(integral x, size_t align) noexcept;
bool is_aligned(void* val, size_t align) noexcept;

template &lt;class integral&gt;
constexpr integral align_up(integral x, size_t align) noexcept;
void* align_up(void* val, size_t align) noexcept;

template &lt;class integral&gt;
constexpr integral align_down(integral x, size_t align) noexcept;
void* align_down(void* val, size_t align) noexcept;

</pre></blockquote>

<h3>Explicit Shifts</h3>
<p>Bit shifting is provided in C++ with <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> for integral types. While this abstraction is generally
useful for the majority of cases there are some deficiencies. 

First as noted earlier, there is no primitive for rotational shifts even though these shifts can be found in the instruction 
set of almost every machine. Second, 
<code>operator&gt;&gt;</code> for signed types has implementation defined behavior with regards to filling in the high order bits, making
it useless for portable code that requires specific behavior on the high order bits.
Writing a portable arithmetic right shift cumbersome at best and inefficient at worst. Finally, performing a logical right shift on a signed
quantity is also cumbersome because it requires an ugly cast. For this reason and for symmetry, we have included mnemonics for 
logical shift.
</p>

<ul>
	<li><code>//SHift Logical Left</code><br/>
	<code>template &lt;class integral&gt; constexpr integral shll(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shifted left by <code>s</code> positions. 
	The <code>s</code> low order bits of the result are set to 0.
	Undefined behavior if <code>(s < 0 || s > sizeof(x) * CHAR_BIT).</code>
	<br/><br/> </li>
	<li><code>//SHift Logical Right</code><br/>
	<code>template &lt;class integral&gt; constexpr integral shlr(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shifted right by <code>s</code> positions.
	The <code>s</code> high order bits of the result are set to 0.
	Undefined behavior if <code>(s < 0 || s > sizeof(x) * CHAR_BIT).</code>
	<br/><br/> </li>
	<li><code>//SHift Arithmetic Left</code><br/>
	<code>template &lt;class integral&gt; constexpr integral shal(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shift left by <code>s</code> positions.
	The <code>s</code> low order bits of the result are set to 0.
	Undefined behavior if <code>s < 0 || s > sizeof(x) * CHAR_BIT.</code>
	<br/><br/> </li>
	<li><code>//SHift Arithmetic Right</code><br/>
	<code>template &lt;class integral&gt; constexpr integral shar(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shift left by <code>s</code> positions.
	The <code>s</code> high order bits of the result are set to the value of the most significant bit in <code>x</code>.
	Undefined behavior if <code>(s < 0 || s > sizeof(x) * CHAR_BIT).</code>
	<br/><br/> </li>
	<li><code>//ROTate Left</code><br/>
	<code>template &lt;class integral&gt; constexpr integral rotl(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shift left by <code>s</code> positions.
	The <code>s</code> low order bits of result are set to the <code>s</code> high order bits of <code>x</code>.
	Undefined behavior if <code>(s < 0 || s > sizeof(x) * CHAR_BIT).</code>
	<br/><br/> </li>
	<li><code>//ROTate Right</code><br/>
	<code>template &lt;class integral&gt; constexpr integral rotr(integral x, int s) noexcept;</code><br/>
	Returns a quantity equivalent to <code>x</code> with all of its bits shift left by <code>s</code> positions.
	The <code>s</code> high order bits of result are set to the <code>s</code> low order bits of <code>x</code>.
	Undefined behavior if <code>(s < 0 || s > sizeof(x) * CHAR_BIT).</code>
	<br/><br/> </li>
</ul>
<h3>Bit Counting Algorithms</h3>
Bit counting is useful in a variety of contexts. Many of these operations have native instructions available on a wide variety of modern hardware.

<ul>
	<li><code>//Count Trailing Zero Bits</code><br/>
	<code>template &lt;class integral&gt; constexpr int cntt0(integral x) noexcept;</code><br/>
	Returns the number of trailing zero bits in <code>x</code>, or <code>(sizeof(x) * CHAR_BIT)</code> if <code>(x == 0)</code>.
	<ul>
		<li>i386: <code>bsf</code>, <code>cmov</code></li>
		<li>x86_64 w/ BMI1: <code>tzcnt</code></li>
		<li>alpha: <code>cttz</code></li>
		<li>gcc/clang: <code>(x == 0 ? sizeof(x) * CHAR_BIT : __builtin_ctz(x))</code>
		<li>&lt;bitops&gt;: <code>cntt1(~x)</code></li>
	</ul>
	<br/></li>
	<li><code>//Count Leading Zero Bits</code><br/>
	<code>template &lt;class integral&gt; constexpr int cntl0(integral x) noexcept;</code><br/>
	Returns the number of leading zero bits in <code>x</code>, or <code>(sizeof(x) * CHAR_BIT)</code> if <code>(x == 0)</code>.
	<ul>
		<li>i386: <code>bsr</code>, <code>cmov</code></li>
		<li>x86_64 w/ SSE4: <code>lzcnt</code></li>
		<li>ARMv5: <code>CLZ</code></li>
		<li>IA64: <code>clz</code></li>
		<li>PowerPC: <code>cntlz[dw]</code></li>
		<li>MIPS: <code>CLZ</code></li>
		<li>gcc/clang: <code>(x == 0 ? sizeof(x) * CHAR_BIT : __builtin_clz(x))</code>
		<li>&lt;bitops&gt;: <code>cntl1(~x)</code></li>
	</ul>
	<br/></li>
	<li><code>//Count Trailing 1 Bits</code><br/>
	<code>template &lt;class integral&gt; constexpr int cntt1(integral x) noexcept;</code><br/>
	Returns the number of trailing 1 bits in <code>x</code>, or <code>(sizeof(x) * CHAR_BIT)</code> if <code>(x == ~intregral(0))</code>.
	<ul>
		<li>&lt;bitops&gt;: <code>cntt0(~x)</code></li>
	</ul>
	<br/></li>
	<li><code>//Count Leading 1 Bits</code><br/>
	<code>template &lt;class integral&gt; constexpr int cntl1(integral x) noexcept;</code><br/>
	Returns the number of leading 1 bits in <code>x</code>, or <code>(sizeof(x) * CHAR_BIT)</code> if <code>(x == ~intregral(0))</code>.
	<ul>
		<li>ARMv8: <code>CLS</code></li>
		<li>Blackfin: <code>SIGNBITS</code></li>
		<li>C6X: <code>NORM</code></li>
		<li>Picochip: <code>SBC</code></li>
		<li>MIPS: <code>CLO</code></li>
		<li>&lt;bitops&gt;: <code>cntl0(~x)</code></li>
	</ul>
	<br/></li>
	<li><code>//POPulation COUNT</code><br/>
	<code>template &lt;class integral&gt; constexpr int popcount(integral x) noexcept;</code><br/>
	Returns the number of 1 bits in <code>x</code>.
	<ul>
		<li>x86_64 SSE4: <code>popcnt</code></li>
		<li>IA64: <code>popcnt</code></li>
		<li>Alpha: <code>CTPOP</code></li>
		<li>PowerPC: <code>popcntb</code></li>
		<li>SparcV9: <code>POPC</code></li>
		<li>gcc: <code>__builtin_popcount()</code></li>
	</ul>
	<br/></li>
	<li><code>//PARITY</code><br/>
	<code>template &lt;class integral&gt; constexpr int parity(integral x) noexcept;</code><br/>
	Returns 1 if the  number of 1 bits in <code>x</code> is odd, else returns 0.
	<ul>
		<li>gcc: <code>__builtin_parity()</code></li>
		<li>&lt;bitops&gt;: <code>popcount(x) & 1</code></li>
	</ul>
	<br/></li>
</ul>

<h3>Rightmost bit manipulation</h3>
The following functions perform simple manipulations on the rightmost bits of the given quantity.
Some of them are implemented in hardware on Intel and AMD machines. All of these operations
consist of a few simple arithmetic and logical operations and thus the C++ implementations
have been included in the descriptions. All of these functions were successfully
detected and converted into their native BMI and/or TBM instructions by the gcc 4.8 optimizer.
Therefore we only present these functions as usability wrappers.

<ul>
	<li><code>//ReSeT Least Significant 1 Bit</code><br/>
	<code>template &lt;class integral&gt; constexpr integral rstls1b(integral x) noexcept;</code><br/>
	Returns <code>x</code> with it's least sigificant 1 bit set to 0, or 0 if <code>x == 0</code>.
	<ul>
		<li>x86_64 w/ BMI1: <code>BLSR</code></li>
		<li>C/C++: <code>(x & (x-1))</code></li>
	</ul>
	<br/></li>

	<li><code>//SET Least Significant 0 Bit</code><br/>
	<code>template &lt;class integral&gt; constexpr integral setls0b(integral x) noexcept;</code><br/>
	Returns <code>x</code> with it's least sigificant 0 bit set to 1, or <code>~intregral(0)</code> if <code>x == ~integral(0)</code>.
	<ul>
		<li>x86_64 w/ AMD TBM: <code>BLCS</code></li>
		<li>C/C++: <code>(x | (x+1))</code></li>
	</ul>
	<br/></li>

	<li><code>//ISOlate Least Significant 1 Bit</code><br/>
	<code>template &lt;class integral&gt; constexpr integral isols1b(integral x) noexcept;</code><br/>
	Returns a quantity with the least significant 1 bit of <code>x</code> set to 1 and all other bits set to 0, or 0 if <code>x == 0</code>.
	<ul>
		<li>C/C++: <code>((~x) & (x+1))</code></li>
	</ul>
	<br/></li>

	<li><code>//ISOlate Least Significant 0 Bit</code><br/>
	<code>template &lt;class integral&gt; constexpr integral isols1b(integral x) noexcept;</code><br/>
	Returns a quantity with the least significant 0 bit of <code>x</code> set to 1 and all other bits set to 0, or 0 if <code>x == 0</code>.
	<ul>
		<li>x86_64 w/ BMI1: <code>BLSI</code></li>
		<li>x86_64 w/ AMD TBM: <code>BLSIC</code>, <code>NOT</code></li>
		<li>C/C++: <code>((~x) & (x+1))</code></li>
	</ul>
	<br/></li>

	<li><code>//ReSeT Trailing 1's</code></li>
	<code>template &lt;class integral&gt; constexpr integral rstt1(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 1 bits set to 0, or 0 if <code>x == 0</code>.
	<ul>
		<li>x86_64 w/ AMD TBM: <code>BLCFILL</code></li>
		<li>C/C++: <code>(x & (x+1))</code></li>
	</ul>
	<br/></li>

	<li><code>//SET Trailing 0's</code></li>
	<code>template &lt;class integral&gt; constexpr integral sett0(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 0 bits set to 1, or <code>~integral(0)</code> if <code>x == ~integral(0)</code>.
	<ul>
		<li>x86_64 w/ AMD TBM: <code>BLSFILL</code></li>
		<li>C/C++: <code>(x | (x - 1))</code></li>
	</ul>
	<br/></li>

	<li><code>//MaSK Trailing 0's</code></li>
	<code>template &lt;class integral&gt; constexpr integral maskt0(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 0 bits set to 1, and all of the other bits set to 0, or <code>~integral(0)</code> if <code>x == 0</code>.
	<ul>
		<li>C/C++: <code>((~x) & (x - 1))</code></li>
	</ul>
	<br/></li>

	<li><code>//MaSK Trailing 1's</code></li>
	<code>template &lt;class integral&gt; constexpr integral maskt1(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 1 bits set to 1, and all of the other bits set to 0, or <code>~integral(0)</code> if <code>x == ~integral(0)</code>.
	<ul>
		<li>C/C++: <code>~((~x) | (x + 1))</code></li>
	</ul>
	<br/></li>

	<li><code>//MaSK Trailing 0's and Least Significant 1 Bit</code></li>
	<code>template &lt;class integral&gt; constexpr integral maskt0ls1b(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 0 bits set and it's least sigificant 1 bit set to 1, all of the other bits set to 0. Returns <code>~integral(0)</code> if <code>x == 0</code>.
	<ul>
		<li>x86_64 w/ BMI1: <code>BLSMSK</code></li>
		<li>x86_64 w/ AMD TBM: <code>TZMSK</code></li>
		<li>C/C++: <code>((x - 1) ^ x)</code></li>
	</ul>
	<br/></li>

	<li><code>//MaSK Trailing 1's and Least Significant 0 Bit</code></li>
	<code>template &lt;class integral&gt; constexpr integral maskt1ls0b(integral x) noexcept;</code><br/>
	Returns <code>x</code> with all of it's trailing 1 bits and it's least sigificant 1 bit set to 1, all of the other bits set to 0. Returns <code>~integral(0)</code> if <code>x == ~integral(0)</code>.
	<ul>
		<li>x86_64 w/ BMI1: <code>BLSMSK</code></li>
		<li>x86_64 w/ AMD TBM: <code>TZMSK</code></li>
		<li>C/C++: <code>((x - 1) ^ x)</code></li>
	</ul>
	<br/></li>
</ul>
<h3>Single Bit Manipulation</h3>
These functions are provided only for usability. They are all trivial to implement.

<ul>
	<li><code>//SET BIT</code></li>
	<code>template &lt;class integral&gt; constexpr integral setbit(integral x, int b) noexcept;</code><br/>
	Sets bit <code>b</code> to 1 in <code>x</code> and returns <code>x</code>. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x | (integral(1) &lt;&lt; b)</code>
	</ul>
	<br/></li>

	<li><code>//ReSeT BIT</code></li>
	<code>template &lt;class integral&gt; constexpr integral rstbit(integral x, int b) noexcept;</code><br/>
	Sets bit <code>b</code> to 0 in <code>x</code> and returns <code>x</code>. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x & ~(integral(1) &lt;&lt; b)</code>
	</ul>
	<br/></li>

	<li><code>//FLIP BIT</code></li>
	<code>template &lt;class integral&gt; constexpr integral flipbit(integral x, int b) noexcept;</code><br/>
	Inverts bit <code>b</code> in <code>x</code> and returns <code>x</code>. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x ^ (integral(1) &lt;&lt; b)</code>
	</ul>
	<br/></li>

	<li><code>//TEST BIT</code></li>
	<code>template &lt;class integral&gt; constexpr bool testbit(integral x, int b) noexcept;</code><br/>
	Returns true if bit <code>b</code> in <code>x</code> is 1. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x & (integral(1) &lt;&lt; b)</code>
	</ul>
	<br/></li>
</ul>

<h3>Range of Bits Manipulation</h3>
The following are for changing a range of bits above or below a given position index.
One of them is implemented in hardware, the rest are provided for symmetry and usability.

<ul>
	<li><code>//ReSeT BITS Greater than or Equal</code></li>
	<code>template &lt;class integral&gt; constexpr integral rstbitsge(integral x, int b) noexcept;</code><br/>
	Sets all bits in positions &ge; <code>b</code> in <code>x<code> to 0. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>x86_64 w/ BMI2: <code>BZHI</code></li>
		<li>C/C++: <code>x & ((integral(1) &lt;&lt; b)-1)</code>
	</ul>
	<br/></li>

	<li><code>//ReSeT BITS Less Than</code></li>
	<code>template &lt;class integral&gt; constexpr integral rstbitsle(integral x, int b) noexcept;</code><br/>
	Sets all bits in positions &le; <code>b</code> in <code>x<code> to 0. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x & ~((integral(1) &lt;&lt; (b+1))-1)</code>
	</ul>
	<br/></li>

	<li><code>//SET BITS Greater than or Equal</code></li>
	<code>template &lt;class integral&gt; constexpr integral setbitsge(integral x, int b) noexcept;</code><br/>
	Sets all bits in positions &ge; <code>b</code> in <code>x<code> to 1. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x | ((integral(1) &lt;&lt; b)-1)</code>
	</ul>
	<br/></li>

	<li><code>//SET BITS Less Than</code></li>
	<code>template &lt;class integral&gt; constexpr integral setbitsle(integral x, int b) noexcept;</code><br/>
	Sets all bits in positions &le; <code>b</code> in <code>x<code> to 1. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x | ~((integral(1) &lt;&lt; (b+1))-1)</code>
	</ul>
	<br/></li>

	<li><code>//FLIP BITS Greater than or Equal</code></li>
	<code>template &lt;class integral&gt; constexpr integral flipbitsge(integral x, int b) noexcept;</code><br/>
        Inverts all bits in positions &ge; <code>b</code> in <code>x<code>. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x ^ ((integral(1) &lt;&lt; b)-1)</code>
	</ul>
	<br/></li>

	<li><code>//FLIP BITS Less Than</code></li>
	<code>template &lt;class integral&gt; constexpr integral flipbitsle(integral x, int b) noexcept;</code><br/>
	Inverts all bits in positions &le; <code>b</code> in <code>x<code>. The result is undefined if <code>(b &lt; 0 || b &gt; sizeof(x) * CHAR_BIT)</code>.
	<ul>
		<li>C/C++: <code>x ^ ~((integral(1) &lt;&lt; (b+1))-1)</code>
	</ul>
	<br/></li>
</ul>

<h3>Power of 2 manipulation</h3>
Detecting and computing powers of 2 has uses in a variety of applications. Some examples are:
<ul>
	<li>A circular queue, where the size is always a power of 2. Restricting the 
	size to a power of 2 allows optimizing the index computation to use logical and instead of modulus.</li>
	<li>In 3d graphics applications, 2 dimensional textures are often required
	have dimensions which are a power of 2. The function <code>ceilp2()</code> can be used to scale
	a non power of 2 image dimensions up to the next power of 2.</li>
</ul>

Detecting whether a number is a power of 2 is an interesting example of a computation whose most efficient
implementation is platform depedent. 

<ul>
	<li><code>//IS POWer of 2</code></li>
	<code>template &lt;class integral&gt; constexpr bool ispow2(integral x) noexcept;</code><br/>
	Returns true if <code>x<code> is a power of 2.
	<ul>
		<li>C/C++: <code>x &gt; 0 && (x & (x-1)) == 0)</code>
		<li>C/C++: <code>x &gt;= 0 && popcount(x) == 0)</code>
	</ul>
	<br/></li>

	<li><code>//CEILing Power of 2</code></li>
	<code>template &lt;class integral&gt; constexpr integral ceilp2(integral x) noexcept;</code><br/>
	Returns the next power of 2 &gt; <code>x</code>.
	<ul>
	</ul>
	<br/></li>

	<li><code>//FLOOR Power of 2</code></li>
	<code>template &lt;class integral&gt; constexpr integral floorp2(integral x) noexcept;</code><br/>
	Returns the next power of 2 &lt; <code>x</code>.
	<ul>
	</ul>
	<br/></li>
</ul>

<h3>General permutations of bits and bytes</h3>
<p>These functions provide a generic interface for permuting the bits and bytes in a word.
All of these functions take at least 3 arguments, the integral value to permute, the
subword size (default=1), and the number of words to permute in parallel (default=1).
</p>
<p>
A subword is defined as a collection of bits. As an example, a byte is a subword of size CHAR_BITS (usually 8),
a nibble is a subword of size 4. A word might be defined as a subword of size 16, 32, or 64, depending on your
platform. Each function operates on the subwords of the given value.
</p>
<p>
For example, <code>reverse_bits(x, 2)</code>, will reverse each pair of bits in <code>x</code>.
<code>reverse_bits(x, 1)</code> or equivalently <code>reverse_bits(x)</code>, will reverse
all of the bits of <code>x</code>. <code>outer_perfect_shuffle_bytes(x)</code> will outer perfect shuffle
all of the bytes of <code>x</code>.
</p>
<p>
The <code>num_words</code> parameter allows operating on multiple words packed into a larger value. This
is the well known SWAR (SIMD within a register) idiom.
For example,
assuming <code>x</code> is a 32 bit integral type, <code>reverse_bytes(x, 1, 2)</code> will
separately reverse the 2 high order bytes of <code>x</code> and the 2 low order bytes of <code>x</code>.
Some machines provide native instructions to permute multiple words at once and thus these operations
can be optimized into a single instruction.
</p>

<p>
For each function there is a variant which operates on subwords whose size is counted in bits
and subwords whose size is counted in bytes.
The byte variants are provided for usability and expressiveness. The bytewise variants are trivially
implementable in terms of their bitwise versions.
<p>Applications</p>
<ul>
	<li>Endian conversion for networking and binary protocols [<a href="N3646">N3646</a>]</li>
	<li>Multimedia</li>
	<li>Cryptography</li>
</ul>

<p>The result of all of the following functions is undefined if</p>
<ul>
	<li><code>subword_bits &le; 0</code></li>
	<li><code>num_words &le; 0</code></li>
	<li><code>num_words * subword_bits &gt; sizeof(x) * CHAR_BIT</code></li>
	<li><code>(sizeof(x) * CHAR_BIT) % (num_words * subword_bits) != 0</code></li>
</ul>

<p>The list of proposed permutation functions is described here:</p>
<ul>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral reverse_bits(integral x, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral reverse_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>Independently reverses the subwords of each word in <code>x</code></p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral outer_perfect_shuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral outer_perfect_shuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>Independently outer perfect shuffles the subwords of each word in <code>x</code></p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral outer_perfect_unshuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral outer_perfect_unshuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>Independently outer perfect unshuffles the subwords of each word in <code>x</code></p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral inner_perfect_shuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral inner_perfect_shuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>Independently inner perfect shuffles the subwords of each word in <code>x</code></p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral inner_perfect_unshuffle_bits(integral x, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral inner_perfect_unshuffle_bytes(integral x, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>Independently inner perfect unshuffles the subwords of each word in <code>x</code></p>
	</li>

	<li>
	<p><code>template &lt;class integral&gt; constexpr integral deposit_bits_right(integral x, integral m, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral deposit_bytes_right(integral x, integral m, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>For each word in <code>x</code>, the low order subwords are replaced with the subwords selected by the bits of mask <code>m</code>.</p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral deposit_bits_left(integral x, integral m, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral deposit_bytes_left(integral x, integral m, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>For each word in <code>x</code>, the high order subwords are replaced with the subwords selected by the bits of mask <code>m</code>.</p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral extract_bits_right(integral x, integral m, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral extract_bytes_right(integral x, integral m, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>For each word in <code>x</code>, the subwords selected by the bits of mask <code>m</code> are replaced by the low order subwords.</p>
	</li>
	<li>
	<p><code>template &lt;class integral&gt; constexpr integral extract_bits_left(integral x, integral m, int subword_bits=1, int num_words=1) noexcept;</code></p>
	<p><code>template &lt;class integral&gt; constexpr integral extract_bytes_left(integral x, integral m, int subword_bytes=1, int num_words=1) noexcept;</code></p>
	<p>For each word in <code>x</code>, the subwords selected by the bits of mask <code>m</code> are replaced by the high order subwords.</p>
	</li>
</ul>

<p>The following table shows how an example 64bit quantity would be permuted by each byte permuting function. The bitwise permuting variants are similar.</p>
<table border="1">
	<tr>
		<th><code>x</code></th>
		<td>0x8877665544332211</td>
	</tr><tr>
		<th><code>reverse_bytes(x)</code></th>
		<td>0x1122334455667788</td>
	</tr><tr>
		<th><code>reverse_bytes(x, 1, 2)</code></th> 
		<td>0x5566778811223344</td>
	</tr><tr>
		<th><code>reverse_bytes(x, 1, 4)</code></th>
		<td>0x7788556633441122</td>
	</tr><tr>
		<th><code>reverse_bytes(x, 2)</code></th>
		<td>0x6655887722114433</td>
	</tr><tr>
		<th><code>reverse_bytes(x, 2, 2)</code></th>
		<td>0x6655887722114433</td>
	</tr><tr>
		<th><code>reverse_bytes(x, 4)</code></th>
		<td>0x4433221188776655</td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x)</code></th>
		<td>0x8844773366225511</td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x, 1, 2)</code></th>
		<td>0x8866775544223311</td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x, 1, 4)</code></th>
		<td align="center"><code>x</code></td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x, 2)</code></th>
		<td>0x8877443366552211</td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x, 2, 2)</code></th>
		<td align="center"><code>x</code></td>
	</tr><tr>
		<th><code>outer_perfect_shuffle_bytes(x, 4)</code></th>
		<td align="center"><code>x</code></td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x)</code></th>
		<td>0x4488337722661155</td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x, 1, 2)</code></th>
		<td>0x6688557722441133</td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x, 1, 4)</code></th>
		<td align="center"><code>reverse_bytes(x, 1, 4)</code></td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x, 2)</code></th>
		<td>0x4433887722116655</td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x, 2, 2)</code></th>
		<td align="center"><code>reverse_bytes(x, 2, 2)</code></td>
	</tr><tr>
		<th><code>inner_perfect_shuffle_bytes(x, 4)</code></th>
		<td align="center"><code>reverse_bytes(x, 4)</code></td>
	</tr>
</table>


<p>Hardware and compiler support:</p>
<ul>
	<li><code>reverse_bits&lt;uin32_t&gt;(x)</code> ARMv7: <code>RBIT</code></li>
	<li><code>reverse_bits&lt;uin64_t&gt;(x)</code> ARMv8: <code>RBIT</code></li>
	<li><code>reverse_bits&lt;uint32_t&gt;(x)</code> EPIPHANY: <code>BITR</code></li>
	<li><code>reverse_bits&lt;uint8_t&gt;(x, 4)</code> AVR: <code>SWAP</code></li>
	<li><code>reverse_bytes&lt;uint32_t&gt;(x)</code> i486: <code>bswap</code></li>
	<li><code>reverse_bytes&lt;uint64_t&gt;(x)</code> x86_64: <code>bswap</code></li>
	<li><code>reverse_bytes&lt;uint16_t&gt;(x)</code> PDP11: <code>SWAB</code></li>
	<li><code>reverse_bytes&lt;uint16_t&gt;(x)</code> gcc: <code>__builtin_bswap16()</code></li>
	<li><code>reverse_bytes&lt;uint32_t&gt;(x)</code> gcc: <code>__builtin_bswap32()</code></li>
	<li><code>reverse_bytes&lt;uint64_t&gt;(x)</code> gcc: <code>__builtin_bswap64()</code></li>
	<li><code>reverse_bytes&lt;uint32_t&gt;(x)</code> ARMv5: <code>REV</code></li>
	<li><code>reverse_bytes&lt;uint64_t&gt;(x)</code> ARMv8: <code>REV</code></li>
	<li><code>reverse_bytes&lt;uint32_t&gt;(x, 1, 2)</code> ARMv6: <code>REV16</code></li>
	<li><code>reverse_bytes&lt;uint64_t&gt;(x, 1, 4)</code> ARMv8: <code>REV16</code></li>
	<li><code>reverse_bytes&lt;uint64_t&gt;(x, 1, 2)</code> ARMv8: <code>REV32</code></li>
	<li><code>reverse_bytes&lt;uint32_t&gt;(x, 2)</code> MC68020: <code>SWAP</code></li>
	<li><code>(int32_t)reverse_bytes&lt;int16_t&gt;(x)</code> ARMv5: <code>REVSH</code></li>
	<li><code>(int32_t)reverse_bytes&lt;unt16_t&gt;(x)</code> ARMv5: <code>REVSH</code></li>
	<li><code>deposit_bits_right&lt;uint32_t&gt;(x)</code> x86_64 w/ BMI2: <code>PDEP</code></li>
	<li><code>deposit_bits_right&lt;uint64_t&gt;(x)</code> x86_64 w/ BMI2: <code>PDEP</code></li>
	<li><code>extract_bits_right&lt;uint32_t&gt;(x)</code> x86_64 w/ BMI2: <code>PDEP</code></li>
	<li><code>extract_bits_right&lt;uint64_t&gt;(x)</code> x86_64 w/ BMI2: <code>PDEP</code></li>
</ul>

<h3>Saturated Arithmetic</h3>
Saturated arithmetic is useful in digital signal processing applications. It is also provided as a hardware instruction
on some machines. In our efforts to better expose hardware features, we have included saturated addition and subtraction functions in this proposal.
These functions are proposed for the &lt;cmath&gt; header.
<ul>
	<li><code>//SATurated ADD</code></li>
	<code>template &lt;class integralL, class integralR&gt; constexpr auto satadd(integralL l, integralR r) noexcept -&gt; decltype(l + r);</code><br/>
	Returns l + r, or std::numeric_limits<decltype(l+r)>::max() if l + r would overflow.
	<ul>
	</ul>
	<br/></li>

	<li><code>//SATurated SUBtract</code></li>
	<code>template &lt;class integralL, class integralR&gt; constexpr auto satsub(integralL l, integralR r) noexcept -&gt; decltype(l - r);</code><br/>
	Returns l - r, or std::numeric_limits<decltype(l-r)>::min() if l - r would underflow.
	<ul>
	</ul>
	<br/></li>
</ul>

<h3>Pointer and Size Alignment Helpers</h3>
<p>These are primitives used for aligning objects in memory. They are proposed for the &lt;memory&gt; header.</p>

<ul>
	<li><code>//IS ALIGNED</code></li>
	<code>template &lt;class integral&gt; constexpr bool is_aligned(integral x, size_t a) noexcept;</code><br/>
	<code>bool is_aligned(void* x, size_t a) noexcept;</code><br/>
	Returns true if <code>x</code> is a multiple of <code>a</code>. The result is undefined if <code>a</code> is not a power of 2.
	<ul>
	</ul>
	<br/></li>

	<li><code>//ALIGN UP</code></li>
	<code>template &lt;class integral&gt; constexpr integral align_up(integral x, size_t a) noexcept;</code><br/>
	<code>void* align_up(void* x, size_t a) noexcept;</code><br/>
	Returns the smaller number n where <code>n &gt;= x && is_aligned(n, a)</code>. The result is undefined if <code>a</code> is not a power of 2.
	<ul>
	</ul>
	<br/></li>

	<li><code>//ALIGN DOWN</code></li>
	<code>template &lt;class integral&gt; constexpr integral align_down(integral x, size_t a) noexcept;</code><br/>
	<code>void* align_down(void* x, size_t a) noexcept;</code><br/>
	Returns the largest number n where <code>n &lt;= x && is_aligned(n, a)</code>. The result is undefined if <code>a</code> is not a power of 2.
	<ul>
	</ul>
	<br/></li>
</ul>

<p>
We currently have <code>std::align</code> in the standard for this purpose. While <code>std::align</code> can
be useful in many cases, the interface was designed for only one very specific use case.
Consider the following example of using aligned SIMD registers to process a memory buffer.
This idiom cannot be expressed using <code>std::align</code>.
</p>
<pre><blockquote>
void process(char* b, char* e) {
  char* pb = std::min((char*)std::align_up(b, sizeof(simd16)), e);
  char* pe = (char*)std::align_down(e, sizeof(simd16));

  for(char* p = b; p &lt; pb; ++p) {
    process1(p);
  }
  for(char* p = pb; p &lt; pe; p += sizeof(simd16)) {
    simd16 x = simd16_aligned_load(p);
    process16(x);
    simd16_aligned_store(x, p);
  }
  for(char* p = pe; p &lt; e; ++p) {
    process1(p);
  }
}
</blockquote></pre>




<h2>
	<a name="Acknowledgements">Acknowledgements</a></h2>

<p>

<h2><a name="References">References</a></h2>
<ul>
	<li>[<a name="Anderson01">Anderson01</a>] Anderson, Sean Eron. <i>Bit Twiddling Hacks</i>,
	Available online at <a href="http://graphics.stanford.edu/~seander/bithacks.html">http://graphics.stanford.edu/~seander/bithacks.html</a></li>
	<li>[<a name="Dietz01">Dietz01</a>] Deitz, Hendry Gordon. <i>The Aggregate Magic Algorithms</i>, University of Kentucky. 
	Available online at <a href="http://aggregate.org/MAGIC/">http://aggregate.org/MAGIC/</a></li>
	<li>[<a name="Neumann01">Neumann01</a>] Neumann, Jasper. <i>Bit permutations</i>, Available online at
	<a href="http://programming.sirrida.de/bit_perm.html">http://programming.sirrida.de/bit_perm.html</a></li>
	<li>[<a name="Warren01">Warren01</a>] Warren, Henry S. Jr. <i>Hacker's Delight Second Edition</i>,
	Addison-Wesley, Oct 2012, ISBN 0-321-84268-5.</li>	
	<li>[<a name="pdp11">pdp11</a>] <i>pdp11/40 process handbook</i>, Digital Equipment Corporation, 1972. </li>
	<li>[<a name="Kostjuchenko01">Kostjuchenko01</a>] Kostjuchenko, Dmitry. <i> SSE2 optimized strlen</i>, Available online at
	<a href="http://www.strchr.com/sse2_optimised_strlen?allcomments=1">http://www.strchr.com/sse2_optimised_strlen?allcomments=1</a></li>
	<li>[<a name="Clang">Clang</a>] <i>clang: a C language family frontend for LLVM</i>, Available online at
	<a href="http://clang.llvm.org/">http://clang.llvm.org/</a></li>
	<li>[<a name="BitOpsReference">BitOpsReference</a>] <i>GitHub: BitOps Proposal and Reference Implementation</i>, Available online at
	<a href="https://github.com/fmatthew5876/stdcxx">https://github.com/fmatthew5876/stdcxx</a></li>
	<li>[<a name="N3646">N3646</a>] Pratte, Robert. <i>Network Byte Order Conversion Document Number: N3646</i>.
	Available online at <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3646.pdf">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3646.pdf</a></li>
</ul>

<hr>




</body></html>

